/*------------------------------------------------------+
 | Author: Maurizio Loreti, aka MLO or (HAM) I3NOO      |
 | Work:   University of Padova - Department of Physics |
 |         Via F. Marzolo, 8 - 35131 PADOVA - Italy     |
 | Phone:  +39 (049) 827-7216   FAX: +39 (049) 827-7102 |
 | EMail:  loreti@pd.infn.it                            |
 | WWW:    http://www.pd.infn.it/~loreti/mlo.html       |
 +------------------------------------------------------+

 Quick-and-dirty program that generates web pages containing a file
 pretty-printed by "source-highlight" (a GNU utility available from
 http://www.gnu.org/software/src-highlite/source-highlight.html).

 The program 'tohtml' should be invoked as:

 tohtml <file> <url> [ <parameters> ]

 - <file> is the name of the file to be pretty printed (let's say
   "source.cxx"); and may be prefixed by a path, like in
   "~/work/source.cxx".
 - <url> contains the host name and the full path of the URL where the
   named file will be available on the net (e.g., giving as <url> the
   string "wwwcdf.pd.infn.it/labo/Source" means that in order to
   obtain the file "source.cxx" we are supposed to open the URL
   "http://wwwcdf.pd.infn.it/labo/Source/source.cxx" in our browser).
 - All the remaining parameters, if any, will be passed to the
   rendering program source-highlight; the default (i.e., when only
   two command line parameters are given to tohtml) is "-s cpp": to
   mean that the language of the input file is C or C++.

 The HTML code is printed to <file>.html, e.g. "source.cxx.html"; if
 <file> contains a path, only the basename is used: and the output
 will be written in the current directory.  A few informative messages
 are printed on the standard output stream (possible error messages
 will go to the standard error stream).

 -------------------------------------------------------------------
 $Id: tohtml.c,v 1.4 2006/11/09 09:49:17 loreti Exp $
 -------------------------------------------------------------------*/

#include <stdio.h>              /* Standard Library */
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>          /* POSIX headers */
#include <sys/stat.h>
#include <unistd.h>

#define BUFLEN 512

static char *baseName(char *);
static char *myStrncpy(char *, const char *, const char *);

int main(
  int   argc,
  char *argv[]
) {

  /**
   | Local variables:
   | - buffer: to store the command to execute source-highlight
   | - progName: the name of the current program (without the eventual
   |   path).
   | - fileName: the name of the input file, without the eventual path
   |   information
   | - outName: the name of the output file
   | - lastBuffer, lastOutName: pointers to the last char of buffer
   |   and outName
  **/

  char         buffer[BUFLEN];
  const char  *lastBuffer = buffer + BUFLEN - 1;
  char        *progName = baseName(argv[0]);
  char        *fileName;
  char         outName[FILENAME_MAX];
  const char  *lastOutName = outName + FILENAME_MAX - 1;
  FILE        *fpOut;
  struct stat  statInfo;
  char        *pc;
  int          saveErrno;

  /**
   | Validation: at least two command line parameters, the first one
   | being the name of a readable file.
  **/

  if (argc < 3) {
    fprintf(stderr, "\nUsage:\t%s <file> <url> [ <par> ]\n\n", progName);
    fputs("- <file>: the source file to be processed;\n", stderr);
    fputs("- <url>:  host and path of the URL where the source file "
          "may be found;\n", stderr);
    fputs("- <par>:  optional parameters to be passed to "
          "source-highlight:\n", stderr);
    fputs("          defaults to \"-s cpp\" (the input language is C "
          "or C++).\n\n", stderr);
    return EXIT_FAILURE;
  }

  if (access(argv[1], R_OK) != 0) {
    saveErrno = errno;
    fprintf(stderr, "%s: file \"%s\" is not available for reading\n"
            "access: %s\n", progName, argv[1], strerror(saveErrno));
    return EXIT_FAILURE;
  }

  if (stat(argv[1], &statInfo) != 0) {
    saveErrno = errno;
    fprintf(stderr, "%s: couldn't stat file \"%s\"\n"
            "stat: %s\n", progName, argv[1], strerror(saveErrno));
    return EXIT_FAILURE;
  }

  /**
   | Builds fileName and outName; opens the output file and writes the
   | HTML preamble
  **/

  fileName = baseName(argv[1]);

  pc = myStrncpy(outName, fileName, lastOutName);
  myStrncpy(pc, ".html", lastOutName);
  if ((fpOut = fopen(outName, "w")) == 0) {
    saveErrno = errno;
    fprintf(stderr, "%s: couldn't open output file \"%s\"\n"
            "fopen: %s\n", progName, outName, strerror(saveErrno));
    return EXIT_FAILURE;
  }

  fputs("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n",
        fpOut);
  fprintf(fpOut, "<!-- Generated by tohtml $Revision: 1.4 $ on %s at %s "
          "-->\n", __DATE__, __TIME__);
  fprintf(fpOut, "<html><head><title>%s</title>\n", fileName);
  fputs("<link rev=\"made\" href=\"mailto:loreti at pd dot "
        "infn dot it\">\n", fpOut);
  fputs("<meta http-equiv=\"Content-Type\" content=\"text/html; "
       "charset=iso-8859-1\">\n", fpOut);
  fputs("</head>\n", fpOut);
  fputs("<body bgcolor=\"#FFFFFF\" text=\"#000000\" "
       "link=\"#0000EE\" vlink=\"#551A8B\" alink=\"#FF0000\">\n",
        fpOut);
  fprintf(fpOut, "<center><h1>%s</h1></center>\n", fileName);
  fputs("<p><hr><p>\n", fpOut);
  fputs("Per salvare il file listato qui avanti, scaricatelo "
        "direttamente\n", fpOut);
  fprintf(fpOut, "<a href=\"http://%s/%s\">da questo link</a>\n",
         argv[2], fileName);
  fputs("(right-click, <em>Save Link As ...</em>).\n", fpOut);
  fputs("<p><hr><p>\n", fpOut);
  fputs("<center>\n", fpOut);
  fputs("<table border=3 cellpadding=10 width=\"90%\" "
       "bgcolor=\"#f5fffa\">\n", fpOut);
  fputs("<tr><td>\n", fpOut);
  if (ferror(fpOut)) {
    saveErrno = errno;
    fprintf(stderr, "%s: error writing output file \"%s\"\n"
            "fprintf/fputs (1): %s\n", progName, outName,
            strerror(saveErrno));
    return EXIT_FAILURE;
  }
  fclose(fpOut);

  /**
   | Builds the command that invokes source-highlight, and appends the
   | highlighted input file to the output file; then reopens the
   | output file to append the HTML trailer.
  **/

  pc = buffer +
    snprintf(buffer, BUFLEN, "source-highlight -i \"%s\" -f html",
             argv[1]);

  if (argc > 3) {
    int i;

    for (i = 3;   argv[i] != 0;   ++i) {
      pc = myStrncpy(pc, " ", lastBuffer);
      pc = myStrncpy(pc, argv[i], lastBuffer);
    }
  } else {
    pc = myStrncpy(pc, " -s cpp", lastBuffer);
  }
  pc = myStrncpy(pc, " >> \"", lastBuffer);
  pc = myStrncpy(pc, outName, lastBuffer);
  pc = myStrncpy(pc, "\"", lastBuffer);

  fprintf(stdout, "%s: %s\n", progName, buffer);
  if (system(buffer) != 0) {
    fprintf(stdout, "%s: failure\n", progName);
    return EXIT_FAILURE;
  } else {
    fprintf(stdout, "%s: success\n", progName);
  }

  if ((fpOut = fopen(outName, "a")) == 0) {
    saveErrno = errno;
    fprintf(stderr, "%s: can't happen\nfopen/append: %s\n",
            progName, strerror(saveErrno));
    return EXIT_FAILURE;
  }

  fputs("</td></tr></table></center>\n", fpOut);
  fputs("<p><hr><p>\n", fpOut);
  fprintf(fpOut, "File name: %s<br>\n", fileName);
  fprintf(fpOut, "File size: %lu bytes<br>\n",
          (unsigned long) statInfo.st_size);
  fprintf(fpOut, "Last modified: %s",
          asctime(localtime(&statInfo.st_mtime)));
  fputs("</body></html>\n", fpOut);
  if (ferror(fpOut)) {
    saveErrno = errno;
    fprintf(stderr, "%s: error writing output file \"%s\"\n"
            "fprintf/fputs (2): %s\n", progName, outName,
            strerror(saveErrno));
    return EXIT_FAILURE;
  }
  fclose(fpOut);

  return EXIT_SUCCESS;
}

/**********************************************************************/
/***************************** baseName *******************************/
/**********************************************************************/

static char *baseName(
  char *pc
){

  /**
   | Strips the (eventual) path information from "pc"; returns a
   | pointer to the terminating '\0' if "pc" ends in '/'.
  **/

  char *p;

  p = strrchr(pc, '/');
  if (p == 0) return pc;
  return ++p;
}

/**********************************************************************/
/***************************** myStrncpy ******************************/
/**********************************************************************/

static char *myStrncpy(
  char       *to,
  const char *from,
  const char *last
) {

  /**
   | Copies the string in "from" to "to", until the '\0' terminator or
   | until the character pointed to by "last"; returns a pointer to
   | the '\0' terminator in "to" (that is always written).
  **/

  while ((*to = *from++) != '\0') {
    if (to == last) {
      *to = '\0';
      break;
    }
    ++to;
  }
  return to;
}
